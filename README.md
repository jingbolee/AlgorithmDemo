# AlgorithmDemo
记录学习算法 Demo 
- 剑指offer
- LeetCode

### 剑指offer
01. 二维数组中的查找  
在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
1. 替换空格  
请实现一个函数，把字符串中的每个空格替换成"%20"，例如“We are happy.”，则输出“We%20are%20happy.”。
1. 从尾到头打印链表   
输入个链表的头结点，从尾到头反过来打印出每个结点的值。
1. 重建二叉树   
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如：前序遍历序列｛ 1, 2, 4, 7, 3, 5, 6, 8｝和中序遍历序列｛4, 7, 2, 1, 5, 3, 8，6}，重建二叉树并输出它的头结点。
1. 用两个栈实现队列   
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。
1. 旋转数组的最小数字   
把一个数组最开始的若干个元素搬到数组的末尾， 我们称之数组的旋转。输入一个递增排序的数组的一个旋转， 输出旋转数组的最小元素。例如数组{3,4,5,1,2 ｝为｛ 1,2,3,4,5}的一个旋转，该数组的最小值为1。
1. 斐波那契数列
写一个函数，输入n，求斐波那契数列的第n项值。
斐波那契数列的定义如下：   
![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/58ebe8b2d5551fb272cd4258940fe1e492592d02)   
![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/c374ba08c140de90c6cbb4c9b9fcd26e3f99ef56)   
![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/4fa6d281e7a54e08aeffeef7458ddc0884333686)
1. 二进制中1的个数   
请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制1001，有2位1。因此如果输入9，该函数输出2。
1. 打印1到最大的n位数   
输入数字n，按顺序打印出从1到n位最大十进数的数值。比如输入3，则打印出1、2、3一直到最大三位数即999。
1. 在O(1)时间删除链表节点   
给定单向链表的一个头指针和节点指针，定义一个函数在O(1)时间删除该节点。
1. 调整数组顺序使奇数位于偶数前面   
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位予数组的后半部分。
1. 链表中倒数第K个节点   
输入一个链表，输出该链表中倒数第k 个结点。为了符合大多数人的习惯，本题从1 开始计数，即链表的尾结点是倒数第1 个结点．例如一个链表有6 个结点，从头结点开始它们的值依次是1 、2、3、4、5 、6。这个个链表的倒数第3 个结点是值为4 的结点。
1. 反转链表   
定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。
1. 合并两个排序的链表   
输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。
1. 树的子结构   
输入两棵二叉树A 和B，判断B 是不是A 的子结构。
1. 二叉树的镜像   
请完成一个函数，输入一个二叉树，该函数输出它的镜像。
1. 顺时针打印矩阵   
输入一个矩阵，按照从外向里以顺时针的顺序依次扫印出每一个数字。
1. 包含min函数的栈   
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小数的min 函数。在该栈中，调用min、push 及pop的时间复杂度都是O(1)。
1. 栈的压入、弹出序列   
输入两个整数序列，第一个序列表示栈的压入顺序，请判断二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。
1. 从上往下打印二叉树   
从上往下打印出二叉树的每个结点，同一层的结点按照从左向右的顺序打印。
1. 二叉搜索树的后序遍历序列   
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true。否则返回false。假设输入的数组的任意两个数字都互不相同。
1. 二叉树中和为某一值得路径   
输入一棵二叉树和一个整数， 打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
1. 复杂链表的复制   
请实现函数ComplexListNode clone(ComplexListNode head),复制一个复杂链表。在复杂链表中，每个结点除了有一个next 域指向下一个结点外，还有一个sibling 指向链表中的任意结点或者null。
1. 二叉搜索树与双向链表   
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
1. 字符串的排列   
输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc。则打印出由字符a、b、c 所能排列出来的所有字符串abc、acb、bac 、bca、cab 和cba 。
1. 数组中出现次数超过一半的数字   
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
1. 最小的k个数   
输入n个整数，找出其中最小的k个数。   
例子说明：   
例如输入4 、5 、1、6、2、7、3 、8 这8 个数字，则最小的4 个数字是1 、2、3 、4
1. 连续子数组的最大和   
输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。   
例子说明：   
例如输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为｛3, 10, -4, 7, 2}。因此输出为该子数组的和18 。
1. 求从1到n的整数中1出现的次数   
输入一个整数n，求从1 到n这n个整数的十进制表示中1 出现的次数。   
举例说明：   
例如输入12 ，从1 到12 这些整数中包含1 的数字有1、10、11 和12，1 一共出现了5 次。
1. 把数组排成最小的数   
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。   
例子说明：   
例如输入数组{3， 32, 321}，则扫描输出这3 个数字能排成的最小数字321323。
1. 丑数   
我们把只包含因子2、3 和5 的数称作丑数（Ugly Number）。求从小到大的顺序的第1500个丑数。   
举例说明：   
例如6、8 都是丑数，但14 不是，它包含因子7。习惯上我们把1 当做第一个丑数。
1. 第一个只出现一次的字符
2. 数组中的逆序对
3. 两个链表的第一个公共结点
4. 在排序数组中出现的次数
5. 二叉树的深度
6. 判断平衡二叉树
7. 数组中只出现一次的数字
8. 和为s的两个数字
9. 和为s的连续正数序列
10. 翻转单词顺序
11. 左旋转字符串
12. n个骰子的点数
13. 扑克牌的顺子
14. 约瑟夫环问题
15. 不用加减乘除做加法
16. 把字符串转换成整数
17. 树中两个结点的最低公共结点
18. 数组中重复的数字
19. 构建乘积数组
20. 正则表达式匹配
21. 表示数值的字符串
22. 字符流中第一个不重复的字符
23. 链表中环的入口结点
24. 删除链表中重复的结点
25. 二叉树的下一个结点
26. 对称的二叉树
27. 把二叉树打印出多行
28. 按之字形顺序打印二叉树
29. 二叉搜索树的第k个结点
30. 数据流中的中位数
31. 滑动窗口的最大值
32. 矩阵中的路径
33. 机器人的运动范围
### LeetCode

### 基础算法
#### 排序
- [冒泡排序（Bubble Sort）](../Algorithm/src/main/java/algorithms/common/sorr/sort.md)
    - 冒泡排序算法
    - 优化后的冒泡排序算法

